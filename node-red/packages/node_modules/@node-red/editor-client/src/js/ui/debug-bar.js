RED.debugBar = (function() {
    var subWindow = null;

    var currentPayload = {};
    // 初始化debug组件侧边栏
    function initDebugSidebar() {
        var options = {
            messageMouseEnter: function(sourceId) {
                if (sourceId) {
                    var n = RED.nodes.node(sourceId);
                    if (n) {
                        n.highlighted = true;
                        n.dirty = true;
                    }
                    RED.view.redraw();
                }
            },
            messageMouseLeave: function(sourceId) {
                if (sourceId) {
                    var n = RED.nodes.node(sourceId);
                    if (n) {
                        n.highlighted = false;
                        n.dirty = true;
                    }
                    RED.view.redraw();
                }
            },
            messageSourceClick: function(sourceId, aliasId, path) {
                // Get all of the nodes that could have logged this message
                if (RED.nodes.workspace(sourceId)) {
                    RED.view.reveal(sourceId);
                    return
                }
                var candidateNodes = [RED.nodes.node(sourceId)]
                if (path) {
                    for (var i=2;i<path.length;i++) {
                        candidateNodes.push(RED.nodes.node(path[i]))
                    }
                }
                if (aliasId) {
                    candidateNodes.push(RED.nodes.node(aliasId));
                }
                if (candidateNodes.length > 1) {
                    // The node is in a subflow. Check to see if the active
                    // workspace is a subflow in the node's parentage. If
                    // so, reveal the relevant subflow instance node.
                    var ws = RED.workspaces.active();
                    for (var i=0;i<candidateNodes.length;i++) {
                        if (candidateNodes[i].z === ws) {
                            RED.view.reveal(candidateNodes[i].id);
                            return
                        }
                    }
                    // The active workspace is unrelated to the node. So
                    // fall back to revealing the top most node
                }
                RED.view.reveal(candidateNodes[0].id);
            },
            clear: function() {
                RED.nodes.eachNode(function(node) {
                    node.highlighted = false;
                    node.dirty = true;
                });
                RED.view.redraw();
            }
        };

        var uiComponents = RED.debug.init(options);

        RED.sidebar.addTab({
            id: "debug",
            label: RED._("debug.sidebar.label"),
            name: RED._("debug.sidebar.name"),
            content: uiComponents.content,
            // toolbar: uiComponents.footer,
            enableOnEdit: true,
            pinned: true,
            iconClass: "fa fa-bug",
            action: "core:show-debug-tab"
        });
        RED.actions.add("core:show-debug-tab",function() { RED.sidebar.show('debug'); });

        var that = this;
        RED._debug = function(msg) {
            that.handleDebugMessage("", {
                name:"debug",
                msg:msg
            });
        };

        this.refreshMessageList = function() {
            RED.debug.refreshMessageList(RED.workspaces.active());
            if (subWindow) {
                try {
                    subWindow.postMessage({event:"workspaceChange",activeWorkspace:RED.workspaces.active()},"*");
                } catch(err) {
                    console.log(err);
                }
            }
        };
        RED.events.on("workspace:change", this.refreshMessageList);

        this.handleDebugMessage = function(t,o) {
            // console.log("->",o.id,o.z,o._alias);
            //
            // sourceNode should be the top-level node - one that is on a flow.
            var sourceNode;
            var pathParts;
            var pathHierarchy;
            if (o.path) {
                // Path is a `/`-separated list of ids that identifies the
                // complete parentage of the node that generated this message.
                //    flow-id/subflow-A-instance/subflow-B-instance

                // If it has one id, that is a top level flow or config node/global
                // each subsequent id is the instance id of a subflow node
                //
                pathParts = o.path.split("/");
                if (pathParts.length === 1) {
                    // The source node is on a flow or is a global/config - so can use its id to find
                    sourceNode = RED.nodes.node(o.id);
                } else if (pathParts.length > 1) {
                    // Highlight the subflow instance node.
                    sourceNode = RED.nodes.node(pathParts[1]);
                }
                const getNodeLabel = (n) => n.name || (typeof n.label === "function" && n.label())  || (typeof n.label === "string" && n.label) || (n.type + ":" + n.id);
                pathHierarchy = pathParts.map((id,index) => {
                    if (index === 0) {
                        if (id === "global") {
                            return { id: sourceNode.id, label: getNodeLabel(sourceNode) }
                        }
                        return { id: id, label: RED.nodes.workspace(id).label } //flow id + name
                    } else {
                        const instanceNode = RED.nodes.node(id)
                        const pathLabel = (instanceNode.name || RED.nodes.subflow(instanceNode.type.substring(8)).name)
                        return { id: id, label: pathLabel }
                    }
                })
                if (pathParts.length === 1 && pathParts[0] !== "global") {
                    pathHierarchy.push({ id: o.id, label: getNodeLabel(sourceNode) })
                }
                if (o._alias) {
                    let aliasNode = RED.nodes.node(o._alias)
                    if (aliasNode) {
                        pathHierarchy.push({ id: o._alias, label: getNodeLabel(aliasNode) })
                    }
                }
            } else {
                // This is probably redundant...
                sourceNode = RED.nodes.node(o.id) || RED.nodes.node(o.z);
            }
            if (sourceNode) {
                var sourceFlow = RED.nodes.workspace(sourceNode.z)
                o._source = {
                    id:sourceNode.id,
                    z:sourceNode.z,
                    name:sourceNode.name,
                    type:sourceNode.type,
                    // _alias identifies the actual logging node. This is
                    // not necessarily the same as sourceNode, which will be
                    // the top-level subflow instance node.
                    // This means the node's name is displayed in the sidebar.
                    _alias:o._alias,
                    flowName: sourceFlow?(sourceFlow.label||sourceNode.z):sourceNode.z,
                    path: pathParts,
                    pathHierarchy: pathHierarchy
                };
            }
            RED.debug.handleDebugMessage(o);
            if (subWindow) {
                try {
                    subWindow.postMessage({event:"message",msg:o},"*");
                } catch(err) {
                    console.log(err);
                }
            }
        };
        RED.comms.subscribe("debug",this.handleDebugMessage);

        this.clearMessageList = function() {
            RED.debug.clearMessageList(true);
            if (subWindow) {
                try {
                    subWindow.postMessage({event:"projectChange"},"*");
                } catch(err) {
                    console.log(err);
                }
            }
        };
        RED.events.on("project:change", this.clearMessageList);
        RED.actions.add("core:clear-debug-messages", function() { RED.debug.clearMessageList(true) });
        RED.actions.add("core:clear-filtered-debug-messages", function() { RED.debug.clearMessageList(true, true) });

        $("#red-ui-sidebar-debug-open").on("click", function(e) {
            e.preventDefault();
            subWindow = window.open(document.location.toString().replace(/[?#].*$/,"")+"debug/view/view.html"+document.location.search,"nodeREDDebugView","menubar=no,location=no,toolbar=no,chrome,height=500,width=600");
            subWindow.onload = function() {
                subWindow.postMessage({event:"workspaceChange",activeWorkspace:RED.workspaces.active()},"*");
            };
        });
        RED.popover.tooltip($("#red-ui-sidebar-debug-open"),RED._('node-red:debug.sidebar.openWindow'));

        // 调试事件处理
        this.handleDebugEvents = function(topic,payload) {
            console.log("->",topic,payload);
            const parts = topic.split("/");
            const id = parts[1];
            // 记录中断节点
            currentPayload = payload;
            // 中断在 nodeId
            switch (id){
                case "pause-on":{
                    RED.notify(RED._("debug.notification.pause"), { type: "success", timeout: 10000 });
                    RED.debug.show(payload.node.id, payload.context)
                    pauseDebug()
                    break
                }
                case "break-on":{
                    // debugger
                    RED.notify(RED._("debug.notification.break"), { type: "warning", timeout: 10000 });
                    RED.debug.show(payload.node.id, payload.context)
                    pauseDebug()
                    break
                }
                case "complete-on":{
                    // 结束
                    currentPayload = {}
                    RED.notify(RED._("debug.notification.complete"), { type: "success", timeout: 10000 });
                    RED.view.clearSelection()
                    stopDebug()
                }
            }
        }

        RED.comms.subscribe("debug/#",this.handleDebugEvents);

        $(window).on('beforeunload',function() {
            if (subWindow) {
                try {
                    subWindow.close();
                } catch(err) {
                    console.log(err);
                }
            }
        });

        this.handleWindowMessage = function(evt) {
            var msg = evt.data;
            if (msg.event === "mouseEnter") {
                options.messageMouseEnter(msg.id);
            } else if (msg.event === "mouseLeave") {
                options.messageMouseLeave(msg.id);
            } else if (msg.event === "mouseClick") {
                options.messageSourceClick(msg.id,msg._alias,msg.path);
            } else if (msg.event === "clear") {
                options.clear();
            }
        };
        window.addEventListener('message',this.handleWindowMessage);
    }


    const debugTypes = {
        "debug": {img: "red/images/debug-alt-small.svg", func: doDebug, label:"debug.name"},
        "running": {img: "red/images/debug-start.svg", func: doRunning, label:"debug.start"},
    };
    var debugType = 'debug';
    var debugStatus = 'stopped';    // stopped 未调试, running 调试中, paused 暂停中
    function changeDebugType(type) {
        debugType = type;
        $("#red-ui-header-button-debug-icon").attr("src",debugTypes[type].img);
        $("#red-ui-header-button-debug-text").text(RED._(debugTypes[type].label))
    }
    function changeDebugStatus(status) {
        debugStatus = status;
        if( status === 'paused' ){
            $("#red-ui-header-button-debug-step-over").show()
        }
        else {
            $("#red-ui-header-button-debug-step-over").hide()
        }
    }
    function startDebug(){
        debugTypes[debugType].func().then(()=> {
            $("#red-ui-header-button-debug-icon").attr("src", "red/images/debug-stop.svg");
            $("#red-ui-header-button-debug-text").text(RED._("debug.stop"))
            changeDebugStatus("running")
        })
    }

    function pauseDebug(){
        $("#red-ui-header-button-debug-icon").attr("src", "red/images/debug-continue.svg");
        $("#red-ui-header-button-debug-text").text(RED._("debug.continue"))
        changeDebugStatus("paused")
    }
    function stopDebug(){
        changeDebugType(debugType)
        changeDebugStatus("stopped")
    }
    function buildDebugToolbar() {
        // 构造调试/运行按钮
        $('<li>' +
            '<span class="red-ui-debug-button-group button-group">' +
                '<a id="red-ui-header-button-debug" class="red-ui-debug-button" href="#">' +
                    '<span class="red-ui-debug-button-content">' +
                        '<img id="red-ui-header-button-debug-icon" src="red/images/debug-alt-small.svg"/>' +
                        '<span id="red-ui-header-button-debug-text">'+RED._("debug.name")+'</span>'+
                    '</span>' +
                '</a>' +
                '<a id="red-ui-header-button-debug-step-over" class="red-ui-debug-button" href="#" style="display: none;">' +
                    '<span class="red-ui-debug-button-content">' +
                        '<img src="red/images/debug-step-over.svg"/>' +
                    '<span>'+RED._("debug.step-over")+'</span>'+
                    '</span>' +
                '</a>' +
                '<a id="red-ui-header-button-debug-options" class="red-ui-debug-button" href="#">' +
                    '<i class="fa fa-caret-down"></i>' +
                '</a>' +
            '</span>' +
          '</li>').prependTo(".red-ui-header-toolbar");
        // 构造菜单
        const mainMenuItems = [
            {id:"debugmenu-item-debug",toggle:"debug-type",icon:"red/images/debug-alt-small.svg",label:RED._("debug.name"),sublabel:RED._("debug.desc"), onselect:function(s) {if(s){changeDebugType("debug")}}},
            {id:"debugmenu-item-running",toggle:"debug-type",icon:"red/images/debug-start.svg",label:RED._("debug.start"),sublabel:RED._("debug.startDesc"),selected: true, onselect:function(s) { if(s){changeDebugType("running")}}},
        ]
        RED.menu.init({id:"red-ui-header-button-debug-options", options: mainMenuItems });

        // 事件,式样,数据处理注册与定义
        $("#red-ui-header-button-debug").on('click', function(event){
            event.preventDefault();
            switch (debugStatus) {
                case "stopped":{    // 调试器停止时,按调试模式启动调试器
                    currentPayload = {}
                    startDebug()
                    break
                }
                case "running":{    // 调试器运行时,停止调试器
                    currentPayload = {}
                    doStop()
                    break
                }
                case "paused":{     // 调试器中断时,继续调试器
                    doContinue()
                    break
                }
            }
        })
        $("#red-ui-header-button-debug-step-over").on('click', function(event){
            event.preventDefault();
            doOneStep()
        })

        // ==================================
        // 构造暂停/继续按钮(默认都是 disabled 的,启动后才会启用)

    }
    // 初始化debug组件
    function init(options) {
        options = options || {};
        // 构造html式样
        buildDebugToolbar();
        // 初始化侧边栏
        initDebugSidebar();

        RED.actions.add("core:debug", doDebug);
        RED.actions.add("core:run", doRunning);
        RED.actions.add("core:single-step", doOneStep);
        RED.actions.add("core:stop", doStop);
        RED.actions.add("core:pause", doPause);
    }

    // ================================================================
    function _findStartNode(allNodes){
        if( allNodes.length === 1 ){
            return allNodes[0]
        }
        const nodeIdArr = {}
        allNodes.forEach(node=>{
            nodeIdArr[node.id] = node
        })
        for(let i = 0; i < allNodes.length; i++) {
            const nodeId = allNodes[i].id
            const nodeLinks = RED.nodes.getNodeLinks(nodeId)
            for(let n = 0; n < nodeLinks.length; n++) {
                const link = nodeLinks[n]
                if( nodeIdArr[link.target.id] !== undefined ){
                    delete nodeIdArr[link.target.id]
                }
            }
        }
        const ids = Object.keys(nodeIdArr)
        for(let i = 0; i < ids.length; i++) {
            const nodeId = ids[i]
            const nodeLinks = RED.nodes.getNodeLinks(nodeId)
            if( nodeLinks.length > 0 ){
                return nodeIdArr[nodeId]
            }
        }
        return undefined
    }


    function buildCommand(customMsg){
        return {
            __context: customMsg || {},
            __breaks: RED.debug.getBreaks()
        }
    }
    function _Command(path, node, label, customMsg) {
        $.ajax({
            url: path,
            type: "POST",
            data: JSON.stringify(buildCommand(customMsg)),
            contentType: "application/json; charset=utf-8",
            success: function (resp) {
                RED.notify(RED._("node-red:inject.success", { label: label }), { type: "success", id: "inject", timeout: 2000 });
            },
            error: function (jqXHR, textStatus, errorThrown) {
                if (jqXHR.status === 404) {
                    RED.notify(RED._("node-red:common.notification.error", { message: RED._("node-red:common.notification.errors.not-deployed") }), "error");
                } else if (jqXHR.status === 500) {
                    RED.notify(RED._("node-red:common.notification.error", { message: RED._("node-red:inject.errors.failed") }), "error");
                } else if (jqXHR.status === 0) {
                    RED.notify(RED._("node-red:common.notification.error", { message: RED._("node-red:common.notification.errors.no-response") }), "error");
                } else {
                    RED.notify(RED._("node-red:common.notification.error", { message: RED._("node-red:common.notification.errors.unexpected", { status: jqXHR.status, message: textStatus }) }), "error");
                }
            }
        });
    }

    function checkFlowNodes() {
        // 获得当前活动工作台流
        const tabNode = RED.nodes.workspace(RED.workspaces.active())
        if( tabNode === undefined || !tabNode){
            // 没有活动工作区
            RED.notify(RED._("debug.error.invalid-workspace"), { type: "error", timeout: 5000 });
            return undefined
        }
        const allNodes = RED.nodes.getWorkspaceAllNodes(tabNode.id)
        // 获得当前流第一个节点
        const frontNode = _findStartNode(allNodes)
        if( frontNode === undefined || !frontNode){
            // 没有找到启动节点
            RED.notify(RED._("debug.error.need-inject"), { type: "error", timeout: 5000 });
            return undefined
        }
        RED.debug.clearMessageList();
        return frontNode
    }

    function getPayloadContext(){
        return currentPayload.context
    }
    function doDebug(){
        return new Promise((resolve, reject) => {
            // 尝试自动保存
            RED.deploy.save(false, true, (state)=>{
                if( state === 'success' ){
                    const startNode = checkFlowNodes()
                    if( !startNode ){
                        return
                    }
                    _Command('inject/debug/' + startNode.id, startNode, RED._("debug.info.debug"),getPayloadContext())
                    resolve()
                } else {
                    reject()
                }
            });
        })
    }
    function doContinue(){
        let startNode = currentPayload.node
        if( !startNode ){
            RED.notify(RED._("debug.error.can-not-continue"), { type: "error", timeout: 5000 });
            return
        }
        _Command('inject/continue/' + startNode.id, startNode, RED._("debug.info.debug"),getPayloadContext())
    }
    function doRunning(){

        return new Promise((resolve, reject) => {
            RED.deploy.save(false, true, (state)=>{
                if( state === 'success' ){
                    const startNode = checkFlowNodes()
                    if( !startNode ){
                        return
                    }
                    _Command("inject/" + startNode.id, startNode, RED._("debug.info.run"))
                    resolve()
                } else {
                    reject()
                }
            });
        })
    }
    function doOneStep(){
        const pauseNode = currentPayload.node
        if( !pauseNode ){
            RED.notify(RED._("debug.error.need-pause"), { type: "error", timeout: 5000 });
            return
        }
        _Command("inject/single/" + pauseNode.id, pauseNode, RED._("debug.info.step"), getPayloadContext())
    }
    function _doEvent(command, label){
        _Command("inject/" + command, undefined,label)
    }
    function doStop(){
        _doEvent('event/stop', RED._("debug.info.stop"))
		stopDebug()
    }
    function doPause(){
        _doEvent('event/pause', RED._("debug.info.pause"))
    }


    // 增加 break 事件
    return {
        init: init,
        test: function(v) {
            console.log("test:" + v)
        }
    }
})();
